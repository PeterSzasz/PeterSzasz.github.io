---
layout: post
author: SzP
title:  "TTRS app"
date:   2021-12-25 09:11:10 +0100
categories: backlog apps ttrs
excerpt_separator: <!--more-->
---
Tetris is a game with very few rules. But to implement these and the game scene you have to learn at least one thing that the pieces are called tetrominos, sometimes.
<!--more-->
I did not know that and still kept replacing some 'i' with an 'o' here and there in that word and then correcting them. Then it turned out Tetriminos is the official name since 2001, so I guess I was always right. Maybe someone mixed those up in the Tetris Committee also, I imagine fights over this up until 2001 when a new era started.
![app image](https://github.com/PeterSzasz/ttrs/raw/main/screenshot.png){: .align-right}
Anyway, the projects base idea was to try pyglet without external assets. Create a game with just lines and pixels, implement a minimalistic menu system on top of this and make it playable. For a while I was planning to create some simple sound effects too. Generating a few sinus based tones with different amplitude and/or frequency values is easy. Then you just have to experiment a little on how to combine them to some comforting bleeps and blops for your mini-game-project. This sound business remains to an other project for this I found some good underwater beeps and bloops.

The State pattern here is based on `GameState` class which contains only method declarations, basically an abstract class without any implementation. A `Menu`, `Running` and `Scores` classes inherit from this base class.
Because of the simplicity of the project the state classes contains not just the graphic generations and the objects necessary to play tetris but the logic for the gui, sound effects and input handling.

In a way the context for these states is the `GUI` class. It's got a set_state and get_state method and every major method calls the appropriate state version. What I mean is that GUI got an `on_key_press` method just like all the state classes and the `GameWindow` class (which inherits it from pyglet's on_key_press). So in the `GameWindow` class, after the state is set, an `on_key_press` method calls the `gui.on_key_press` method which looks like this:
{% highlight python %}
def on_key_press(self, key, modifiers):
    if self.state:
        self.state.on_key_press(key, modifiers)
{% endhighlight %}
The control handed over to the active state. Same happens in the `on_update` and `on_draw` methods.
Worth mentioning that in the `on_draw` method just before the state related drawings happen the blitting of the background image. In pyglet if you want to draw something from pixel to pixel you have to blit images onto images. Because of this in `GUI`'s init I define a pixel and two grid sized boxes. In `draw_background` these boxes repaint the previous frame's background, basically erasing any previous modifications from state drawings.
{% highlight python %}
class GUI:
    def __init__(self, width, height) -> None:

        # plain canvas for background
        self.image = pyglet.image.SolidColorImagePattern((11,111,11,255)).create_image(self.width, self.height).get_texture()

        # building blocks
        self.white_pixel = pyglet.image.SolidColorImagePattern((255,255,255,255)).create_image(2,2)
        self.black_box = pyglet.image.SolidColorImagePattern((0,0,0,255)).create_image(self.grid_width-1,self.grid_height-1)
        self.grey_box = pyglet.image.SolidColorImagePattern((20,20,20,255)).create_image(self.grid_width-1,self.grid_height-1)

    def draw_background(self):
        row = 0
        for x in range(0, self.width, self.grid_width):
            for y in range(0, self.height, self.grid_height):
                row += 1
                if 5<row and row<11:    # a greyish belt
                    self.image.blit_into(self.grey_box, x+1, y+1, 0)
                else:                   # black background
                    self.image.blit_into(self.black_box, x+1, y+1, 0)
            row = 0

    def on_draw(self):
        self.image.blit(0,0)
        self.draw_background()
        if self.state:
            self.state.on_draw()
{% endhighlight %}


Shapes class contains the description of tetrmominos. The `coords` and `color` are extensively used by basic movement, collision and drawing methods. The `bottom_left` and `top_right` was used in the now deprecated `rotate` method inside Shapes but not anywhere else. First I tought a kind of bounding box should be used for wall and floor collision detection but eventually checking every gox of a trtromino is just as easy and can be used in any other collision check also. One algo rule them all.
{% highlight python %}
class Shapes:
    def __init__(self) -> None:
        self.tetrominoes = {
            'box':{'coords':[(-1,-1),(0,-1),(0,0),(-1,0)],'bottom_left':(-1,-1),'top_right':(0,0),'color':'red'},
            'L-shape':{'coords':[(-1,-1),(0,-1),(0,0),(0,1)],'bottom_left':(-1,-1),'top_right':(0,1),'color':'red'},
            ...
            }
{% endhighlight %}

Collision detection happens in the `Map` class. Not the best place for this but not a big deal either so it stays.
Shape rotation in Shapes class is based on vectors and rotation matrices.
{% highlight python %}
    def rotate_player(self, clockwise=True):
        '''
        Rotate right (by default) or left 90 degree the given shape.
        rot matrix for 90degr: [(0,-1),(1,0)]
        rot matrix for -90degr: [(0,1),(-1,0)]
        cw: sin(90)=-1 cos(90)=0
        cc: sin(90)=1 cos(90)=0
        '''
        new_shape_coords = []
        valid = True
        for coord in self.player_shape['coords']:
            if clockwise:                    
                new_shape_coords.append( (coord[1],-1*coord[0]) )
            else:
                new_shape_coords.append( (-1*coord[1],coord[0]) )
        for grid in new_shape_coords:
            if not self.is_valid(self.player_pivot[0] + grid[0],self.player_pivot[1] + grid[1]):
                valid = False
        if valid:
            for grid in self.player_shape['coords']:
                x = self.player_pivot[0] + grid[0]
                y = self.player_pivot[1] + grid[1]
                self.color_grid(x,y,None)
            self.player_shape['coords'] = new_shape_coords
            color = self.player_shape['color']
            for grid in self.player_shape['coords']:
                x = self.player_pivot[0] + grid[0]
                y = self.player_pivot[1] + grid[1]
                self.color_grid(x,y,color)
        return valid
{% endhighlight %}

{% highlight python %}
{% endhighlight %}